# 
msgid ""
msgstr ""
"Project-Id-Version: Presto 0.94-SNAPSHOT\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-02-09 22:35+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../src/main/sphinx/develop/functions.rst:3
msgid "Functions"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:5
msgid ""
"The function framework is used to implement SQL functions. Presto includes a"
" number of built-in functions, and an internal ``Plugin`` (plugins that have"
" a dependency on presto-main) can provide new functions by returning a "
"``FunctionFactory`` from ``getServices()``."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:20
msgid ""
"The above code implements a new function ``is_null`` which takes a single "
"``VARCHAR`` argument, and returns a ``BOOLEAN`` indicating if the argument "
"was ``NULL``. Note that the argument to the function is of type ``Slice``. "
"``VARCHAR`` uses ``Slice``, which is essentially a wrapper around "
"``byte[]``, rather than ``String`` for its native container type."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:26
msgid "``@SqlType``:"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:28
msgid ""
"The ``@SqlType`` annotation is used to declare the return type and the "
"argument types. Note, that the return type and arguments of the Java code, "
"must match the native container types of the corresponding annotations."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:32
msgid "``@Nullable``:"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:34
msgid ""
"The ``@Nullable`` annotation indicates that the argument may be ``NULL``. "
"Without this annotation the framework assumes that all functions return "
"``NULL`` if any of their arguments are ``NULL``. When working with a "
"``Type`` that has a primitive native container type, such as ``BigintType``,"
" use the object wrapper for the native container type when using "
"``@Nullable``. The method must be annotated with ``@Nullable`` if it can "
"return ``NULL`` when the arguments are non-null."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:43
msgid "Aggregation Functions"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:45
msgid ""
"Aggregation functions use a similar framework to scalar functions, but "
"involve a bit more complexity."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:48
msgid "``AccumulatorState``:"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:50
msgid ""
"All aggregation functions accumulate input rows into a state object; this "
"object must implement ``AccumulatorState``. For simple aggregations, just "
"extend ``AccumulatorState`` into a new interface with the getters and "
"setters you want, and the framework will generate all the implementations "
"and serializers for you. If you need a more complex state object, you will "
"need to implement ``AccumulatorStateFactory`` and "
"``AccumulatorStateSerializer`` and provide these via the "
"``AccumulatorStateMetadata`` annotation."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:91
msgid ""
"The above code implements the aggregation function ``avg`` which computes "
"the average of a ``DOUBLE`` column."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:94
msgid "``@InputFunction``:"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:96
msgid ""
"The ``@InputFunction`` annotation declares the function which accepts input "
"rows and stores them in the ``AccumulatorState``. Similar to scalar "
"functions you must annotate the arguments with ``@SqlType``. In this "
"example, the input function simply keeps track of the running count of rows "
"(via ``setLong()``) and the running sum (via ``setDouble()``)."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:102
msgid "``@CombineFunction``:"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:104
msgid ""
"The ``@CombineFunction`` annotation declares the function used to combine "
"two state objects. This function is used to merge all the partial "
"aggregation states. It takes two state objects, and merges the results into "
"the first one (in the above example, just by adding them together)."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:109
msgid "``@OutputFunction``:"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:111
msgid ""
"The ``@OutputFunction`` is the last function called when computing an "
"aggregation. It takes the final state object (the result of merging all "
"partial states) and writes the result to a ``BlockBuilder``."
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:115
msgid ""
"Where does serialization happen, and what is ``@GroupedAccumulatorState``?"
msgstr ""

#: ../../src/main/sphinx/develop/functions.rst:117
msgid ""
"The ``@InputFunction`` is usually run on a different worker from the "
"``@CombineFunction``, so the state objects are serialized and transported "
"between these workers by the aggregation framework. "
"``@GroupedAccumulatorState`` is used when performing a ``GROUP BY`` "
"aggregation, and an implementation will be automatically generated for you, "
"if you don't specify a ``AccumulatorStateFactory``"
msgstr ""
