# 
msgid ""
msgstr ""
"Project-Id-Version: Presto 0.94-SNAPSHOT\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-02-09 22:35+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../src/main/sphinx/sql/select.rst:3
msgid "SELECT"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:6
msgid "Synopsis"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:20
msgid "where ``from_item`` is one of"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:31
msgid "Description"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:33
msgid "Retrieve rows from zero or more tables."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:36
msgid "GROUP BY Clause"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:38
msgid ""
"The ``GROUP BY`` clause divides the output of a ``SELECT`` statement into "
"groups of rows containing matching values. A ``GROUP BY`` clause may contain"
" any expression composed of input columns or it may be an ordinal number "
"selecting an output column by position (starting at one)."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:43
msgid ""
"The following queries are equivalent. They both group the output by the "
"``nationkey`` input column with the first query using the ordinal position "
"of the output column and the second query using the input column name::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:52
msgid ""
"``GROUP BY`` clauses can group output by input column names not appearing in"
" the output of a select statement. For example, the following query "
"generates row counts for the ``customer`` table using the input column "
"``mktsegment``::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:69
msgid ""
"When a ``GROUP BY`` clause is used in a ``SELECT`` statement all output "
"expression must be either aggregate functions or columns present in the "
"``GROUP BY`` clause."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:74
msgid "HAVING Clause"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:76
msgid ""
"The ``HAVING`` clause is used in conjunction with aggregate functions and "
"the ``GROUP BY`` clause to control which groups are selected. A ``HAVING`` "
"clause eliminates groups that do not satisfy the given conditions. "
"``HAVING`` filters groups after groups and aggregates are computed."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:81
msgid ""
"The following example queries the ``customer`` table and selects groups with"
" an account balance greater than the specified value::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:106
msgid "UNION Clause"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:108
msgid ""
"The ``UNION`` clause is used to combine the results of more than one select "
"statement into a single result set:"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:115
msgid ""
"The argument ``ALL`` or ``DISTINCT`` controls which rows are included in the"
" final result set. If the argument ``ALL`` is specified all rows are "
"included even if the rows are identical.  If the argument ``DISTINCT`` is "
"specified only unique rows are included in the combined result set. If "
"neither is specified, the behavior defaults to ``DISTINCT``."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:121
msgid ""
"The following is an example of one of the simplest possible ``UNION`` "
"clauses. The following query selects the value ``13`` and combines this "
"result set with a second query which selects the value ``42``::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:137
msgid ""
"Multiple unions are processed left to right, unless the order is explicitly "
"specified via parentheses."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:141
msgid "ORDER BY Clause"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:143
msgid ""
"The ``ORDER BY`` clause is used to sort a result set by one or more output "
"expressions:"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:150
msgid ""
"Each expression may be composed of output columns or it may be an ordinal "
"number selecting an output column by position (starting at one). The ``ORDER"
" BY`` clause is evaluated as the last step of a query after any ``GROUP BY``"
" or ``HAVING`` clause."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:156
msgid "LIMIT Clause"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:158
msgid ""
"The ``LIMIT`` clause restricts the number of rows in the result set. The "
"following example queries a large table, but the limit clause restricts the "
"output to only have five rows (because the query lacks an ``ORDER BY``, "
"exactly which rows are returned is arbitrary)::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:177
msgid "TABLESAMPLE"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:179
msgid "There are multiple sample methods:"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:191
msgid "``BERNOULLI``"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:182
msgid ""
"Each row is selected to be in the table sample with a probability of the "
"sample percentage. When a table is sampled using the Bernoulli method, all "
"physical blocks of the table are scanned and certain rows are skipped (based"
" on a comparison between the sample percentage and a random value calculated"
" at runtime)."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:188
msgid ""
"The probability of a row being included in the result is independent from "
"any other row. This does not reduce the time required to read the sampled "
"table from disk. It may have an impact on the total query time if the "
"sampled output is processed further."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:203
msgid "``SYSTEM``"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:194
msgid ""
"This sampling method divides the table into logical segments of data and "
"samples the table at this granularity. This sampling method either selects "
"all the rows from a particular segment of data or skips it (based on a "
"comparison between the sample percentage and a random value calculated at "
"runtime)."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:200
msgid ""
"The rows selected in a system sampling will be dependent on which connector "
"is used. For example, when used with Hive, it is dependent on how the data "
"is laid out on HDFS. This method does not guarantee independent sampling "
"probabilities."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:205
msgid ""
"Neither of the two methods allow deterministic bounds on the number of rows "
"returned."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:207
msgid "Examples::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:215
msgid "Using sampling with joins::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:225
msgid "UNNEST"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:227
msgid ""
"``UNNEST`` can be used to expand an :ref:`array_type` or :ref:`map_type` "
"into a relation. Arrays are expanded into a single column, and maps are "
"expanded into two columns (key, value). ``UNNEST`` can also be used with "
"multiple arguments, in which case they are expanded into multiple columns, "
"with as many rows as the highest cardinality argument (the other columns are"
" padded with nulls). ``UNNEST`` is normally used with a ``JOIN`` and can "
"reference columns from relations on the left side of the join."
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:234
msgid "Using a single column::"
msgstr ""

#: ../../src/main/sphinx/sql/select.rst:240
msgid "Using multiple columns::"
msgstr ""
